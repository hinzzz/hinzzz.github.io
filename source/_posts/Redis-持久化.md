---
title: redis持久化
author: hinzzz
categories: redis
date: 2021/09/12
keywords: [redis持久化教程,redis两种持久化策略优劣势,redis持久化配置]
description: 本文主要介绍redis持久化教程
---



### Redis的两种持久化优劣势

> Redis是一个内存数据库，数据是保存在内存中的，数据在内存中读取很快，但是也容易发生丢失，服务器重启，宕机都会导致内存的数据被清楚。Redis提供了两种持久化机制，分别是RDB(Redis Database) 和AOF(Append Only File)



#### 一、RDB

> ​		**在指定的时间间隔内将内存中的数据集快照写入磁盘**，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。Redis会单独创建fork一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能如果需要进行大规模数据的恢复，**且对于数据恢复的完整性不是非常敏感**，那RDB方式要比AOF方式更加的高效。**RDB的缺点是最后一次持久化后的数据可能丢失。**



##### 1、用法

Redis会将数据集的快照dump到dump.rdb文件中。此外，我们也可以通过配置文件来修改Redis服务器dump快照的频率，在打开6379.conf文件之后，我们搜索save，可以看到下面的配置信息：

1. save 900 1       #在900秒(15分钟)之后，如果至少有1个key发生变化，则dump内存快照
2. save 300 10      #在300秒(5分钟)之后，如果至少有10个key发生变化，则dump内存快照。
3. save 60 10000    #在60秒(1分钟)之后，如果至少有10000个key发生变化，则dump内存快照。

##### 2、优劣势

1. 适合大规模的数据恢复
2. 对数据完整性和一致性要求不高
3. 在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改
4. fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟



##### 3、如何停止

```shell
redis-cli config set save ""
```



#### 二、AOF

> 以**日志的形式**来记录每个**写操作**，将Redis执行过的所有写指令记录下来(**读操作不记录**)，**只许追加文件但不可以改写文件**，redis启动之初会读取该文件重新构建数据，换言之，**redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作**



##### 1、启动&恢复

1. 启动：appendonly yes 配置文件开启
2. 正常恢复：将有数据的aof文件复制一份保存到对应目录(config get dir) 重启redis重新加载
3. 异常恢复：redis-check-aof --fix进行修复 重启redis重新加载

##### 2、rewrite

1. 是什么：AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制**,当AOF文件的大小超过所设定的阈值时**，**Redis就会启动AOF文件的内容压缩**，只保留可以恢复数据的最小指令集.可以使用命令bgrewriteaof
2. 原理：AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，遍历新进程的内存中数据，每条记录有一条的Set语句。重写aof文件的操作，**并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件**，这点和快照有点类似(Redis Server启动，如果AOF机制打开那么初始化AOF状态，并且如果存在AOF文件，读取AOF文件。随着Redis不断接受命令，每个写命令都被添加到AOF文件，**AOF文件膨胀到需要rewrite时又或者接收到客户端的bgrewriteaof命令**。fork出一个子进程进行rewrite，而父进程继续接受命令，现在的写操作命令都会被额外添加到一个aof_rewrite_buf_blocks缓冲中。当子进程rewrite结束后，父进程收到子进程退出信号，把aof_rewrite_buf_blocks的缓冲添加到rewrite后的文件中，然后切换AOF的文件fd。rewrite任务完成，继续第二个步骤。)

##### 3、优劣势

1. 每修改同步：appendfsync always  同步持久化 每次发生数据变更会被立即记录到磁盘 性能较差但数据完整性比较好
2. 每秒同步：appendfsync everysec  异步操作，每秒记录  如果一秒内宕机，有数据丢失
3. 不同步：appendfsync no  从不同步
4. 相同数据集的数据而言aof文件要远大于rdb文件，恢复速度慢于rdb
5. aof运行效率要慢于rdb,每秒同步策略效率较好，不同步效率和rdb相同



