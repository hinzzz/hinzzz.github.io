---
title: 一条sql的执行过程
author: hinzzz
categories: mysql
date: 2021/11/08
keywords: [mysql,一条sql的执行过程,sql执行过程]
description: 本文主要介绍mysql的基础架构和mysql的执行过程
---





#### 基础架构：一条sql的执行过程



<img src="http://hinzzz.oss-cn-shenzhen.aliyuncs.com/img/hinzzz下载.png" alt="下载" style="zoom: 33%;" />

大体来说，mysql氛围Server层和存储引擎两部分



Server层包括连接器，查询缓存，分析器，优化器，执行器，涵盖mysql的大多数核心功能，以及所有的内置函数（如日期函数，时间，加密，数学函数），所有跨存储引擎的功能都在这里实现，比如存储过程，触发器，视图等



而存储层负责数据的存储和提取。**架构模式是插件式的**，支持InnoDB、MyISAM、Memory等过个存储引擎	默认和最常用的是InnoDB，不同的存储层公用一个Server层。



#### 一、连接器

连接数据库，只有连接上数据库才能进行操作 这个过程会判断账号密码是否正确，和你是否拥有权限

```mysql
mysql -h$ip -P$port -u$user -p
```

连接成功后我们可以查看链接情况

```mysql
show processlist
```

![image-20210916161422115](http://hinzzz.oss-cn-shenzhen.aliyuncs.com/img/hinzzzimage-20210916161422115.png)

数据库里面，**长连接**是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。**短连接**则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。

建立链接的过程是比较复杂和消耗性能的，如果我们全部查询都使用长链接，mysql的内存可能会长得特别快，因为mysql在执行过程中临时使用的内存是管理在链接对象里面的。这些资源只有在断开连接的时候才会释放，所以如果长链接长时间累积就会发生OOM。



怎么解决这个问题呢？这里提供了两种方法：

1. 定期断开长链接
2. 如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。



#### 二、查询缓存

建立链接成功后，你就可以执行select语句了，执行逻辑就会走到第二步：查询缓存



Mysql拿到一个查询缓存后，会在缓存中看是不是之前就已经执行过了，之前如果执行过了，会将sql和结果以键值对的形式存下来，被缓存在内存中，如果这次查询能够在内存中找到，会直接返回上次的查询结果。否则，进行查询。



**但是大多数情况下不推荐使用缓存！**

因为查询缓存的失效非常频繁，只要有对一个表的更新，这个表上的查询缓存都会被清空。因此，很可能你很费劲的把查询结果缓存下来，还没使用，就被一下子清空了。对于更新压力大的数据库，缓存的命中率极低，除非你使用的是静态表，很长时间才会更新。



我们可以查看缓存是否开启`show variables like '%query_cache_type%'`，如果你想对某条sql进行缓存显示调用`select SQL_CACHE * from T where ID=10；`



**需要注意的是这个功能在Mysql 8.0就抛弃了。**





#### 三、分析器

如果没有开启缓存功能或者没有命中缓存，就要开始执行sql语句了。首先，Mysql需要知道你做什么，因此需要对sql语句进行解析。



分析器先会做**词法分析**，Mysql需要识别出sql语句里面的字符串是什么、代表什么，Mysql从你输入的select的关键字识别出来，这是个查询语句，然后也要把table_name识别出来，把字符串“id”识别成对应的列。



做完看**词法分析**，**词法分析器会根据mysql语法规则**，判断你输入的sql语句是否满足mysql语法，如果不满足就抛异常

```mysql
ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'elect * from t where ID=1' at line 1
```



#### 四、优化器

经过了分析器，mysql已经知道你要做什么了。再开始执行之前，还要经过优化器的处理。



优化器是在表里有多个索引的时候，决定使用哪个索引，或者在一个语句有多个关联表时，决定各个表的链接顺序

```mysql
select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;
```

+ 既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。
+ 也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。



这两种方法的执行结果是一样的，但是执行的效率不同，而优化器的作用是决定使用哪种方法更合适



#### 五、执行器

mysql通过分析器已经知道该怎么做了，于是进入了执行器阶段

开始执行的时候，执行器先判断你是否有权限，如果没有，会返回权限错误

```mysql
select * from T where ID=10;
 
ERROR 1142 (42000): SELECT command denied to user 'b'@'localhost' for table 'T'
```

如果有权限，就打开表继续，执行器就会根据表的引擎定义，去使用这个引擎提供的接口，假如上面这个例子的id没有索引

1. 调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；
2. 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。
3. 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。

至此，这个语句就执行完成了



假如id有索引，遍历逻辑其实差不多，比不过是在索引的数据结果中遍历。



#### 每日命令

```mysql
#查看全局变量
show variables
```

